"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultWalletKeys = exports.getDefaultCosigner = exports.getKeyName = exports.getUncompressedKeyTriple = exports.getKeyTriple = exports.getKey = void 0;
const bip32_1 = require("bip32");
const crypto = require("crypto");
const bitgo_1 = require("../bitgo");
const noble_ecc_1 = require("../noble_ecc");
const networks_1 = require("../networks");
const bip32 = (0, bip32_1.BIP32Factory)(noble_ecc_1.ecc);
function getKey(seed) {
    return bip32.fromSeed(crypto.createHash('sha256').update(seed).digest());
}
exports.getKey = getKey;
function getKeyTriple(seed) {
    return [getKey(seed + '.0'), getKey(seed + '.1'), getKey(seed + '.2')];
}
exports.getKeyTriple = getKeyTriple;
function getUncompressedKey(input) {
    // Using input for deterministic randomness
    return noble_ecc_1.ECPair.makeRandom({
        compressed: false,
        network: networks_1.networks.testnet,
        rng: () => {
            return Buffer.alloc(32, input);
        },
    });
}
function getUncompressedKeyTriple(inputs) {
    return [getUncompressedKey(inputs[0]), getUncompressedKey(inputs[1]), getUncompressedKey(inputs[2])];
}
exports.getUncompressedKeyTriple = getUncompressedKeyTriple;
function getKeyName(triple, k) {
    return ['user', 'backup', 'bitgo'][triple.indexOf(k)];
}
exports.getKeyName = getKeyName;
function getDefaultCosigner(keyset, signer) {
    const eq = (a, b) => a === b || (Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.equals(b));
    const [user, backup, bitgo] = keyset;
    if (eq(signer, user)) {
        return bitgo;
    }
    if (eq(signer, backup)) {
        return bitgo;
    }
    if (eq(signer, bitgo)) {
        return user;
    }
    throw new Error(`signer not in pubkeys`);
}
exports.getDefaultCosigner = getDefaultCosigner;
function getDefaultWalletKeys() {
    return new bitgo_1.RootWalletKeys(getKeyTriple('default'));
}
exports.getDefaultWalletKeys = getDefaultWalletKeys;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90ZXN0dXRpbC9rZXlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUErRDtBQUMvRCxpQ0FBaUM7QUFHakMsb0NBQTBDO0FBQzFDLDRDQUE0RDtBQUM1RCwwQ0FBdUM7QUFFdkMsTUFBTSxLQUFLLEdBQWEsSUFBQSxvQkFBWSxFQUFDLGVBQUcsQ0FBQyxDQUFDO0FBSzFDLFNBQWdCLE1BQU0sQ0FBQyxJQUFZO0lBQ2pDLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQzNFLENBQUM7QUFGRCx3QkFFQztBQUVELFNBQWdCLFlBQVksQ0FBQyxJQUFZO0lBQ3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFGRCxvQ0FFQztBQUVELFNBQVMsa0JBQWtCLENBQUMsS0FBSztJQUMvQiwyQ0FBMkM7SUFDM0MsT0FBTyxrQkFBTSxDQUFDLFVBQVUsQ0FBQztRQUN2QixVQUFVLEVBQUUsS0FBSztRQUNqQixPQUFPLEVBQUUsbUJBQVEsQ0FBQyxPQUFPO1FBQ3pCLEdBQUcsRUFBRSxHQUFXLEVBQUU7WUFDaEIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqQyxDQUFDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQWdCLHdCQUF3QixDQUFDLE1BQXNCO0lBQzdELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZHLENBQUM7QUFGRCw0REFFQztBQUVELFNBQWdCLFVBQVUsQ0FBQyxNQUE4QixFQUFFLENBQWlCO0lBQzFFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsZ0NBRUM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBSSxNQUFpQixFQUFFLE1BQVM7SUFDaEUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFJLEVBQUUsQ0FBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUM7SUFDckMsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRTtRQUNyQixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFiRCxnREFhQztBQUVELFNBQWdCLG9CQUFvQjtJQUNsQyxPQUFPLElBQUksc0JBQWMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBRkQsb0RBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCSVAzMkFQSSwgQklQMzJGYWN0b3J5LCBCSVAzMkludGVyZmFjZSB9IGZyb20gJ2JpcDMyJztcclxuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XHJcblxyXG5pbXBvcnQgeyBUcmlwbGUgfSBmcm9tICcuLi9iaXRnbyc7XHJcbmltcG9ydCB7IFJvb3RXYWxsZXRLZXlzIH0gZnJvbSAnLi4vYml0Z28nO1xyXG5pbXBvcnQgeyBlY2MsIEVDUGFpciwgRUNQYWlySW50ZXJmYWNlIH0gZnJvbSAnLi4vbm9ibGVfZWNjJztcclxuaW1wb3J0IHsgbmV0d29ya3MgfSBmcm9tICcuLi9uZXR3b3Jrcyc7XHJcblxyXG5jb25zdCBiaXAzMjogQklQMzJBUEkgPSBCSVAzMkZhY3RvcnkoZWNjKTtcclxuXHJcbmV4cG9ydCB0eXBlIEtleVRyaXBsZSA9IFRyaXBsZTxCSVAzMkludGVyZmFjZT47XHJcbmV4cG9ydCB0eXBlIFVuY29tcHJlc3NlZEtleVRyaXBsZSA9IFRyaXBsZTxFQ1BhaXJJbnRlcmZhY2U+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEtleShzZWVkOiBzdHJpbmcpOiBCSVAzMkludGVyZmFjZSB7XHJcbiAgcmV0dXJuIGJpcDMyLmZyb21TZWVkKGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2VlZCkuZGlnZXN0KCkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5VHJpcGxlKHNlZWQ6IHN0cmluZyk6IEtleVRyaXBsZSB7XHJcbiAgcmV0dXJuIFtnZXRLZXkoc2VlZCArICcuMCcpLCBnZXRLZXkoc2VlZCArICcuMScpLCBnZXRLZXkoc2VlZCArICcuMicpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VW5jb21wcmVzc2VkS2V5KGlucHV0KSB7XHJcbiAgLy8gVXNpbmcgaW5wdXQgZm9yIGRldGVybWluaXN0aWMgcmFuZG9tbmVzc1xyXG4gIHJldHVybiBFQ1BhaXIubWFrZVJhbmRvbSh7XHJcbiAgICBjb21wcmVzc2VkOiBmYWxzZSxcclxuICAgIG5ldHdvcms6IG5ldHdvcmtzLnRlc3RuZXQsXHJcbiAgICBybmc6ICgpOiBCdWZmZXIgPT4ge1xyXG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDMyLCBpbnB1dCk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5jb21wcmVzc2VkS2V5VHJpcGxlKGlucHV0czogVHJpcGxlPG51bWJlcj4pOiBVbmNvbXByZXNzZWRLZXlUcmlwbGUge1xyXG4gIHJldHVybiBbZ2V0VW5jb21wcmVzc2VkS2V5KGlucHV0c1swXSksIGdldFVuY29tcHJlc3NlZEtleShpbnB1dHNbMV0pLCBnZXRVbmNvbXByZXNzZWRLZXkoaW5wdXRzWzJdKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlOYW1lKHRyaXBsZTogVHJpcGxlPEJJUDMySW50ZXJmYWNlPiwgazogQklQMzJJbnRlcmZhY2UpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gIHJldHVybiBbJ3VzZXInLCAnYmFja3VwJywgJ2JpdGdvJ11bdHJpcGxlLmluZGV4T2YoayldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdENvc2lnbmVyPFQ+KGtleXNldDogVHJpcGxlPFQ+LCBzaWduZXI6IFQpOiBUIHtcclxuICBjb25zdCBlcSA9IChhOiBULCBiOiBUKSA9PiBhID09PSBiIHx8IChCdWZmZXIuaXNCdWZmZXIoYSkgJiYgQnVmZmVyLmlzQnVmZmVyKGIpICYmIGEuZXF1YWxzKGIpKTtcclxuICBjb25zdCBbdXNlciwgYmFja3VwLCBiaXRnb10gPSBrZXlzZXQ7XHJcbiAgaWYgKGVxKHNpZ25lciwgdXNlcikpIHtcclxuICAgIHJldHVybiBiaXRnbztcclxuICB9XHJcbiAgaWYgKGVxKHNpZ25lciwgYmFja3VwKSkge1xyXG4gICAgcmV0dXJuIGJpdGdvO1xyXG4gIH1cclxuICBpZiAoZXEoc2lnbmVyLCBiaXRnbykpIHtcclxuICAgIHJldHVybiB1c2VyO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25lciBub3QgaW4gcHVia2V5c2ApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFdhbGxldEtleXMoKTogUm9vdFdhbGxldEtleXMge1xyXG4gIHJldHVybiBuZXcgUm9vdFdhbGxldEtleXMoZ2V0S2V5VHJpcGxlKCdkZWZhdWx0JykpO1xyXG59XHJcbiJdfQ==