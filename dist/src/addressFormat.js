"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCanonicalFormat = exports.toOutputScriptTryFormats = exports.toOutputScriptAndFormat = exports.toOutputScriptWithFormat = exports.fromOutputScriptWithFormat = exports.isSupportedAddressFormat = exports.addressFormats = void 0;
/**
 * Implements methods for nonstandard (non-canonical) address formats.
 *
 * Use `toOutputScriptTryFormats()` instead of `toOutputScript()` to parse addresses in
 * non-canonical formats
 */
const networks_1 = require("./networks");
const address_1 = require("./address");
const bitgo_1 = require("./bitgo");
exports.addressFormats = ['default', 'cashaddr'];
/**
 * @param format
 * @param network
 * @return true iff format is supported for network
 */
function isSupportedAddressFormat(format, network) {
    switch (format) {
        case 'default':
            return true;
        case 'cashaddr':
            return [networks_1.networks.bitcoincash, networks_1.networks.ecash].includes((0, networks_1.getMainnet)(network));
    }
    throw new Error(`unknown address format ${format}`);
}
exports.isSupportedAddressFormat = isSupportedAddressFormat;
/**
 * @param outputScript
 * @param format
 * @param network
 * @return address formatted using provided AddressFormat
 */
function fromOutputScriptWithFormat(outputScript, format, network) {
    if (!isSupportedAddressFormat(format, network)) {
        throw new Error(`unsupported address format ${format} for network ${(0, networks_1.getNetworkName)(network)}`);
    }
    switch ((0, networks_1.getMainnet)(network)) {
        case networks_1.networks.bitcoincash:
        case networks_1.networks.ecash:
            return bitgo_1.bcashAddress.fromOutputScriptWithFormat(outputScript, format, network);
        default:
            return (0, address_1.fromOutputScript)(outputScript, network);
    }
}
exports.fromOutputScriptWithFormat = fromOutputScriptWithFormat;
/**
 * @param address
 * @param format
 * @param network
 * @return output script parsed with provided AddressFormat
 */
function toOutputScriptWithFormat(address, format, network) {
    if (!isSupportedAddressFormat(format, network)) {
        throw new Error(`unsupported address format ${format} for network ${(0, networks_1.getNetworkName)(network)}`);
    }
    switch ((0, networks_1.getMainnet)(network)) {
        case networks_1.networks.bitcoincash:
        case networks_1.networks.ecash:
            return bitgo_1.bcashAddress.toOutputScriptWithFormat(address, format, network);
        default:
            return (0, address_1.toOutputScript)(address, network);
    }
}
exports.toOutputScriptWithFormat = toOutputScriptWithFormat;
/**
 * Attempts to parse address with different address formats, returns first hit.
 * @param address
 * @param network
 * @param formats - defaults to all supported address formats for network
 * @return tuple with [AddressFormat, Buffer] containing format and parsed output script
 */
function toOutputScriptAndFormat(address, network, formats) {
    if (!formats) {
        formats = exports.addressFormats.filter((f) => isSupportedAddressFormat(f, network));
    }
    for (const format of formats) {
        try {
            return [format, toOutputScriptWithFormat(address, format, network)];
        }
        catch (e) {
            // try next
        }
    }
    throw new Error(`could not parse outputScript [formats=${formats}]`);
}
exports.toOutputScriptAndFormat = toOutputScriptAndFormat;
/**
 * Same as `toOutputScriptAndFormat`, only returning script
 * @param address - {@see toOutputScriptAndFormat}
 * @param network - {@see toOutputScriptAndFormat}
 * @param formats - {@see toOutputScriptAndFormat}
 * @return parsed output script
 */
function toOutputScriptTryFormats(address, network, formats) {
    const [, outputScript] = toOutputScriptAndFormat(address, network, formats);
    return outputScript;
}
exports.toOutputScriptTryFormats = toOutputScriptTryFormats;
/**
 * @param address
 * @param network
 * @return address in canonical format
 */
function toCanonicalFormat(address, network) {
    return (0, address_1.fromOutputScript)(toOutputScriptTryFormats(address, network), network);
}
exports.toCanonicalFormat = toCanonicalFormat;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkcmVzc0Zvcm1hdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hZGRyZXNzRm9ybWF0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7OztHQUtHO0FBQ0gseUNBQTJFO0FBQzNFLHVDQUE2RDtBQUU3RCxtQ0FBdUM7QUFFMUIsUUFBQSxjQUFjLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFVLENBQUM7QUFJL0Q7Ozs7R0FJRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLE1BQXFCLEVBQUUsT0FBZ0I7SUFDOUUsUUFBUSxNQUFNLEVBQUU7UUFDZCxLQUFLLFNBQVM7WUFDWixPQUFPLElBQUksQ0FBQztRQUNkLEtBQUssVUFBVTtZQUNiLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLFdBQVcsRUFBRSxtQkFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFBLHFCQUFVLEVBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztLQUMvRTtJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQVJELDREQVFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQiwwQkFBMEIsQ0FBQyxZQUFvQixFQUFFLE1BQXFCLEVBQUUsT0FBZ0I7SUFDdEcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsRUFBRTtRQUM5QyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixNQUFNLGdCQUFnQixJQUFBLHlCQUFjLEVBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ2hHO0lBRUQsUUFBUSxJQUFBLHFCQUFVLEVBQUMsT0FBTyxDQUFDLEVBQUU7UUFDM0IsS0FBSyxtQkFBUSxDQUFDLFdBQVcsQ0FBQztRQUMxQixLQUFLLG1CQUFRLENBQUMsS0FBSztZQUNqQixPQUFPLG9CQUFZLENBQUMsMEJBQTBCLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoRjtZQUNFLE9BQU8sSUFBQSwwQkFBZ0IsRUFBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDbEQ7QUFDSCxDQUFDO0FBWkQsZ0VBWUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLE9BQWUsRUFBRSxNQUFxQixFQUFFLE9BQWdCO0lBQy9GLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEVBQUU7UUFDOUMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsTUFBTSxnQkFBZ0IsSUFBQSx5QkFBYyxFQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNoRztJQUVELFFBQVEsSUFBQSxxQkFBVSxFQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzNCLEtBQUssbUJBQVEsQ0FBQyxXQUFXLENBQUM7UUFDMUIsS0FBSyxtQkFBUSxDQUFDLEtBQUs7WUFDakIsT0FBTyxvQkFBWSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDekU7WUFDRSxPQUFPLElBQUEsd0JBQWMsRUFBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDM0M7QUFDSCxDQUFDO0FBWkQsNERBWUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQix1QkFBdUIsQ0FDckMsT0FBZSxFQUNmLE9BQWdCLEVBQ2hCLE9BQXlCO0lBRXpCLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDWixPQUFPLEdBQUcsc0JBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLHdCQUF3QixDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQzlFO0lBRUQsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7UUFDNUIsSUFBSTtZQUNGLE9BQU8sQ0FBQyxNQUFNLEVBQUUsd0JBQXdCLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixXQUFXO1NBQ1o7S0FDRjtJQUVELE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQWxCRCwwREFrQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxPQUFlLEVBQUUsT0FBZ0IsRUFBRSxPQUF5QjtJQUNuRyxNQUFNLENBQUMsRUFBRSxZQUFZLENBQUMsR0FBRyx1QkFBdUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVFLE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUM7QUFIRCw0REFHQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxPQUFlLEVBQUUsT0FBZ0I7SUFDakUsT0FBTyxJQUFBLDBCQUFnQixFQUFDLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMvRSxDQUFDO0FBRkQsOENBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSW1wbGVtZW50cyBtZXRob2RzIGZvciBub25zdGFuZGFyZCAobm9uLWNhbm9uaWNhbCkgYWRkcmVzcyBmb3JtYXRzLlxyXG4gKlxyXG4gKiBVc2UgYHRvT3V0cHV0U2NyaXB0VHJ5Rm9ybWF0cygpYCBpbnN0ZWFkIG9mIGB0b091dHB1dFNjcmlwdCgpYCB0byBwYXJzZSBhZGRyZXNzZXMgaW5cclxuICogbm9uLWNhbm9uaWNhbCBmb3JtYXRzXHJcbiAqL1xyXG5pbXBvcnQgeyBnZXRNYWlubmV0LCBnZXROZXR3b3JrTmFtZSwgTmV0d29yaywgbmV0d29ya3MgfSBmcm9tICcuL25ldHdvcmtzJztcclxuaW1wb3J0IHsgZnJvbU91dHB1dFNjcmlwdCwgdG9PdXRwdXRTY3JpcHQgfSBmcm9tICcuL2FkZHJlc3MnO1xyXG5cclxuaW1wb3J0IHsgYmNhc2hBZGRyZXNzIH0gZnJvbSAnLi9iaXRnbyc7XHJcblxyXG5leHBvcnQgY29uc3QgYWRkcmVzc0Zvcm1hdHMgPSBbJ2RlZmF1bHQnLCAnY2FzaGFkZHInXSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCB0eXBlIEFkZHJlc3NGb3JtYXQgPSAodHlwZW9mIGFkZHJlc3NGb3JtYXRzKVtudW1iZXJdO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBmb3JtYXRcclxuICogQHBhcmFtIG5ldHdvcmtcclxuICogQHJldHVybiB0cnVlIGlmZiBmb3JtYXQgaXMgc3VwcG9ydGVkIGZvciBuZXR3b3JrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBwb3J0ZWRBZGRyZXNzRm9ybWF0KGZvcm1hdDogQWRkcmVzc0Zvcm1hdCwgbmV0d29yazogTmV0d29yayk6IGJvb2xlYW4ge1xyXG4gIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICBjYXNlICdkZWZhdWx0JzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlICdjYXNoYWRkcic6XHJcbiAgICAgIHJldHVybiBbbmV0d29ya3MuYml0Y29pbmNhc2gsIG5ldHdvcmtzLmVjYXNoXS5pbmNsdWRlcyhnZXRNYWlubmV0KG5ldHdvcmspKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGFkZHJlc3MgZm9ybWF0ICR7Zm9ybWF0fWApO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIG91dHB1dFNjcmlwdFxyXG4gKiBAcGFyYW0gZm9ybWF0XHJcbiAqIEBwYXJhbSBuZXR3b3JrXHJcbiAqIEByZXR1cm4gYWRkcmVzcyBmb3JtYXR0ZWQgdXNpbmcgcHJvdmlkZWQgQWRkcmVzc0Zvcm1hdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21PdXRwdXRTY3JpcHRXaXRoRm9ybWF0KG91dHB1dFNjcmlwdDogQnVmZmVyLCBmb3JtYXQ6IEFkZHJlc3NGb3JtYXQsIG5ldHdvcms6IE5ldHdvcmspOiBzdHJpbmcge1xyXG4gIGlmICghaXNTdXBwb3J0ZWRBZGRyZXNzRm9ybWF0KGZvcm1hdCwgbmV0d29yaykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYWRkcmVzcyBmb3JtYXQgJHtmb3JtYXR9IGZvciBuZXR3b3JrICR7Z2V0TmV0d29ya05hbWUobmV0d29yayl9YCk7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKGdldE1haW5uZXQobmV0d29yaykpIHtcclxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbmNhc2g6XHJcbiAgICBjYXNlIG5ldHdvcmtzLmVjYXNoOlxyXG4gICAgICByZXR1cm4gYmNhc2hBZGRyZXNzLmZyb21PdXRwdXRTY3JpcHRXaXRoRm9ybWF0KG91dHB1dFNjcmlwdCwgZm9ybWF0LCBuZXR3b3JrKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmcm9tT3V0cHV0U2NyaXB0KG91dHB1dFNjcmlwdCwgbmV0d29yayk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGFkZHJlc3NcclxuICogQHBhcmFtIGZvcm1hdFxyXG4gKiBAcGFyYW0gbmV0d29ya1xyXG4gKiBAcmV0dXJuIG91dHB1dCBzY3JpcHQgcGFyc2VkIHdpdGggcHJvdmlkZWQgQWRkcmVzc0Zvcm1hdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvT3V0cHV0U2NyaXB0V2l0aEZvcm1hdChhZGRyZXNzOiBzdHJpbmcsIGZvcm1hdDogQWRkcmVzc0Zvcm1hdCwgbmV0d29yazogTmV0d29yayk6IEJ1ZmZlciB7XHJcbiAgaWYgKCFpc1N1cHBvcnRlZEFkZHJlc3NGb3JtYXQoZm9ybWF0LCBuZXR3b3JrKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhZGRyZXNzIGZvcm1hdCAke2Zvcm1hdH0gZm9yIG5ldHdvcmsgJHtnZXROZXR3b3JrTmFtZShuZXR3b3JrKX1gKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAoZ2V0TWFpbm5ldChuZXR3b3JrKSkge1xyXG4gICAgY2FzZSBuZXR3b3Jrcy5iaXRjb2luY2FzaDpcclxuICAgIGNhc2UgbmV0d29ya3MuZWNhc2g6XHJcbiAgICAgIHJldHVybiBiY2FzaEFkZHJlc3MudG9PdXRwdXRTY3JpcHRXaXRoRm9ybWF0KGFkZHJlc3MsIGZvcm1hdCwgbmV0d29yayk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdG9PdXRwdXRTY3JpcHQoYWRkcmVzcywgbmV0d29yayk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGFyc2UgYWRkcmVzcyB3aXRoIGRpZmZlcmVudCBhZGRyZXNzIGZvcm1hdHMsIHJldHVybnMgZmlyc3QgaGl0LlxyXG4gKiBAcGFyYW0gYWRkcmVzc1xyXG4gKiBAcGFyYW0gbmV0d29ya1xyXG4gKiBAcGFyYW0gZm9ybWF0cyAtIGRlZmF1bHRzIHRvIGFsbCBzdXBwb3J0ZWQgYWRkcmVzcyBmb3JtYXRzIGZvciBuZXR3b3JrXHJcbiAqIEByZXR1cm4gdHVwbGUgd2l0aCBbQWRkcmVzc0Zvcm1hdCwgQnVmZmVyXSBjb250YWluaW5nIGZvcm1hdCBhbmQgcGFyc2VkIG91dHB1dCBzY3JpcHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b091dHB1dFNjcmlwdEFuZEZvcm1hdChcclxuICBhZGRyZXNzOiBzdHJpbmcsXHJcbiAgbmV0d29yazogTmV0d29yayxcclxuICBmb3JtYXRzPzogQWRkcmVzc0Zvcm1hdFtdXHJcbik6IFtBZGRyZXNzRm9ybWF0LCBCdWZmZXJdIHtcclxuICBpZiAoIWZvcm1hdHMpIHtcclxuICAgIGZvcm1hdHMgPSBhZGRyZXNzRm9ybWF0cy5maWx0ZXIoKGYpID0+IGlzU3VwcG9ydGVkQWRkcmVzc0Zvcm1hdChmLCBuZXR3b3JrKSk7XHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBmb3JtYXRzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gW2Zvcm1hdCwgdG9PdXRwdXRTY3JpcHRXaXRoRm9ybWF0KGFkZHJlc3MsIGZvcm1hdCwgbmV0d29yayldO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyB0cnkgbmV4dFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgcGFyc2Ugb3V0cHV0U2NyaXB0IFtmb3JtYXRzPSR7Zm9ybWF0c31dYCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIGB0b091dHB1dFNjcmlwdEFuZEZvcm1hdGAsIG9ubHkgcmV0dXJuaW5nIHNjcmlwdFxyXG4gKiBAcGFyYW0gYWRkcmVzcyAtIHtAc2VlIHRvT3V0cHV0U2NyaXB0QW5kRm9ybWF0fVxyXG4gKiBAcGFyYW0gbmV0d29yayAtIHtAc2VlIHRvT3V0cHV0U2NyaXB0QW5kRm9ybWF0fVxyXG4gKiBAcGFyYW0gZm9ybWF0cyAtIHtAc2VlIHRvT3V0cHV0U2NyaXB0QW5kRm9ybWF0fVxyXG4gKiBAcmV0dXJuIHBhcnNlZCBvdXRwdXQgc2NyaXB0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9PdXRwdXRTY3JpcHRUcnlGb3JtYXRzKGFkZHJlc3M6IHN0cmluZywgbmV0d29yazogTmV0d29yaywgZm9ybWF0cz86IEFkZHJlc3NGb3JtYXRbXSk6IEJ1ZmZlciB7XHJcbiAgY29uc3QgWywgb3V0cHV0U2NyaXB0XSA9IHRvT3V0cHV0U2NyaXB0QW5kRm9ybWF0KGFkZHJlc3MsIG5ldHdvcmssIGZvcm1hdHMpO1xyXG4gIHJldHVybiBvdXRwdXRTY3JpcHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gYWRkcmVzc1xyXG4gKiBAcGFyYW0gbmV0d29ya1xyXG4gKiBAcmV0dXJuIGFkZHJlc3MgaW4gY2Fub25pY2FsIGZvcm1hdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2Fub25pY2FsRm9ybWF0KGFkZHJlc3M6IHN0cmluZywgbmV0d29yazogTmV0d29yayk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGZyb21PdXRwdXRTY3JpcHQodG9PdXRwdXRTY3JpcHRUcnlGb3JtYXRzKGFkZHJlc3MsIG5ldHdvcmspLCBuZXR3b3JrKTtcclxufVxyXG4iXX0=