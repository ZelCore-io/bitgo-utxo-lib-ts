"use strict";
/**
 * Contains helper methods for determining if a transaction output belongs to a given BitGo wallet
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTotalAmountOfInternalOutputs = exports.findInternalOutputIndices = exports.getTotalAmountOfWalletOutputs = exports.findWalletOutputIndices = exports.isWalletOutput = exports.deriveKeyPairForOutput = void 0;
const types_1 = require("../../types");
const outputScripts_1 = require("../../outputScripts");
const UtxoPsbt_1 = require("../../UtxoPsbt");
const utils_1 = require("bip174/src/lib/utils");
const RootNodes_1 = require("./RootNodes");
/**
 * Derives the appropriate BIP32 key pair for a given output.
 * It uses either tapBip32Derivation or bip32Derivation paths from the output.
 * @param bip32 - The BIP32Interface object to derive from.
 * @param output - The specific PSBT output to derive for.
 * @returns The derived BIP32 key pair if master fingerprint matches, or undefined.
 */
function deriveKeyPairForOutput(bip32, output) {
    var _a, _b;
    return ((_a = output.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)
        ? UtxoPsbt_1.UtxoPsbt.deriveKeyPair(bip32, output.tapBip32Derivation, { ignoreY: true })
        : ((_b = output.bip32Derivation) === null || _b === void 0 ? void 0 : _b.length)
            ? UtxoPsbt_1.UtxoPsbt.deriveKeyPair(bip32, output.bip32Derivation, { ignoreY: false })
            : undefined;
}
exports.deriveKeyPairForOutput = deriveKeyPairForOutput;
/**
 * Determines if a specified output in a PSBT is an output of the wallet represented by the given root nodes.
 * @param psbt - The PSBT to check.
 * @param outputIndex - The index of the output to check.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns A boolean indicating if the output belongs to the wallet.
 */
function isWalletOutput(psbt, outputIndex, rootWalletNodes) {
    const output = (0, utils_1.checkForOutput)(psbt.data.outputs, outputIndex);
    const pubKeys = rootWalletNodes.map((rootNode) => { var _a; return (_a = deriveKeyPairForOutput(rootNode, output)) === null || _a === void 0 ? void 0 : _a.publicKey; });
    if (!(0, types_1.isBufferArray)(pubKeys)) {
        return false;
    }
    const outputScript = psbt.getOutputScript(outputIndex);
    return outputScripts_1.scriptTypes2Of3.some((scriptType) => (0, outputScripts_1.createOutputScript2of3)(pubKeys, scriptType).scriptPubKey.equals(outputScript));
}
exports.isWalletOutput = isWalletOutput;
/**
 * Finds indices of all outputs in a PSBT that belong to the wallet represented by the given root nodes.
 * @param psbt - The PSBT to search through.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns An array of indices corresponding to wallet outputs.
 */
function findWalletOutputIndices(psbt, rootWalletNodes) {
    return psbt.data.outputs.flatMap((_, i) => (isWalletOutput(psbt, i, rootWalletNodes) ? [i] : []));
}
exports.findWalletOutputIndices = findWalletOutputIndices;
/**
 * Calculates the total amount of all wallet outputs in a PSBT for the wallet represented by the given root nodes.
 * @param psbt - The PSBT to calculate for.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns The total amount of wallet outputs.
 */
function getTotalAmountOfWalletOutputs(psbt, rootWalletNodes) {
    const indices = findWalletOutputIndices(psbt, rootWalletNodes);
    const txOutputs = psbt.txOutputs;
    return indices.reduce((sum, i) => sum + txOutputs[i].value, BigInt(0));
}
exports.getTotalAmountOfWalletOutputs = getTotalAmountOfWalletOutputs;
/**
 * Finds indices of all internal outputs in a PSBT, identified as outputs belonging to the wallet's root nodes within the PSBT.
 * @param psbt - The PSBT containing the wallet's root nodes as indicated by global Xpubs.
 * @returns An array of indices of internal outputs.
 */
function findInternalOutputIndices(psbt) {
    const rootNodes = (0, RootNodes_1.getSortedRootNodes)(psbt);
    return findWalletOutputIndices(psbt, rootNodes);
}
exports.findInternalOutputIndices = findInternalOutputIndices;
/**
 * Calculates the total amount of all internal outputs in a PSBT, identified as outputs belonging to the wallet's root nodes within the PSBT.
 * @param psbt - The PSBT containing the wallet's root nodes as indicated by global Xpubs.
 * @returns The total amount of internal outputs.
 */
function getTotalAmountOfInternalOutputs(psbt) {
    const rootNodes = (0, RootNodes_1.getSortedRootNodes)(psbt);
    return getTotalAmountOfWalletOutputs(psbt, rootNodes);
}
exports.getTotalAmountOfInternalOutputs = getTotalAmountOfInternalOutputs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHNidE91dHB1dHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vd2FsbGV0L3BzYnQvUHNidE91dHB1dHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCx1Q0FBb0Q7QUFDcEQsdURBQThFO0FBQzlFLDZDQUEwQztBQUUxQyxnREFBc0Q7QUFFdEQsMkNBQWlEO0FBRWpEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLEtBQXFCLEVBQUUsTUFBa0I7O0lBQzlFLE9BQU8sQ0FBQSxNQUFBLE1BQU0sQ0FBQyxrQkFBa0IsMENBQUUsTUFBTTtRQUN0QyxDQUFDLENBQUMsbUJBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUM3RSxDQUFDLENBQUMsQ0FBQSxNQUFBLE1BQU0sQ0FBQyxlQUFlLDBDQUFFLE1BQU07WUFDaEMsQ0FBQyxDQUFDLG1CQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO1lBQzNFLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDaEIsQ0FBQztBQU5ELHdEQU1DO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsY0FBYyxDQUFDLElBQWMsRUFBRSxXQUFtQixFQUFFLGVBQXVDO0lBQ3pHLE1BQU0sTUFBTSxHQUFHLElBQUEsc0JBQWMsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUU5RCxNQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsV0FBQyxPQUFBLE1BQUEsc0JBQXNCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQywwQ0FBRSxTQUFTLENBQUEsRUFBQSxDQUFDLENBQUM7SUFFdkcsSUFBSSxDQUFDLElBQUEscUJBQWEsRUFBQyxPQUFPLENBQUMsRUFBRTtRQUMzQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN2RCxPQUFPLCtCQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FDekMsSUFBQSxzQ0FBc0IsRUFBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FDOUUsQ0FBQztBQUNKLENBQUM7QUFiRCx3Q0FhQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsSUFBYyxFQUFFLGVBQXVDO0lBQzdGLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRyxDQUFDO0FBRkQsMERBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLDZCQUE2QixDQUFDLElBQWMsRUFBRSxlQUF1QztJQUNuRyxNQUFNLE9BQU8sR0FBRyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDL0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUNqQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBSkQsc0VBSUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IseUJBQXlCLENBQUMsSUFBYztJQUN0RCxNQUFNLFNBQVMsR0FBRyxJQUFBLDhCQUFrQixFQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNDLE9BQU8sdUJBQXVCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFIRCw4REFHQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQiwrQkFBK0IsQ0FBQyxJQUFjO0lBQzVELE1BQU0sU0FBUyxHQUFHLElBQUEsOEJBQWtCLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsT0FBTyw2QkFBNkIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUhELDBFQUdDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvbnRhaW5zIGhlbHBlciBtZXRob2RzIGZvciBkZXRlcm1pbmluZyBpZiBhIHRyYW5zYWN0aW9uIG91dHB1dCBiZWxvbmdzIHRvIGEgZ2l2ZW4gQml0R28gd2FsbGV0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgaXNCdWZmZXJBcnJheSwgVHJpcGxlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzLCBzY3JpcHRUeXBlczJPZjMgfSBmcm9tICcuLi8uLi9vdXRwdXRTY3JpcHRzJztcclxuaW1wb3J0IHsgVXR4b1BzYnQgfSBmcm9tICcuLi8uLi9VdHhvUHNidCc7XHJcbmltcG9ydCB7IEJJUDMySW50ZXJmYWNlIH0gZnJvbSAnYmlwMzInO1xyXG5pbXBvcnQgeyBjaGVja0Zvck91dHB1dCB9IGZyb20gJ2JpcDE3NC9zcmMvbGliL3V0aWxzJztcclxuaW1wb3J0IHsgUHNidE91dHB1dCB9IGZyb20gJ2JpcDE3NC9zcmMvbGliL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBnZXRTb3J0ZWRSb290Tm9kZXMgfSBmcm9tICcuL1Jvb3ROb2Rlcyc7XHJcblxyXG4vKipcclxuICogRGVyaXZlcyB0aGUgYXBwcm9wcmlhdGUgQklQMzIga2V5IHBhaXIgZm9yIGEgZ2l2ZW4gb3V0cHV0LlxyXG4gKiBJdCB1c2VzIGVpdGhlciB0YXBCaXAzMkRlcml2YXRpb24gb3IgYmlwMzJEZXJpdmF0aW9uIHBhdGhzIGZyb20gdGhlIG91dHB1dC5cclxuICogQHBhcmFtIGJpcDMyIC0gVGhlIEJJUDMySW50ZXJmYWNlIG9iamVjdCB0byBkZXJpdmUgZnJvbS5cclxuICogQHBhcmFtIG91dHB1dCAtIFRoZSBzcGVjaWZpYyBQU0JUIG91dHB1dCB0byBkZXJpdmUgZm9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBCSVAzMiBrZXkgcGFpciBpZiBtYXN0ZXIgZmluZ2VycHJpbnQgbWF0Y2hlcywgb3IgdW5kZWZpbmVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUtleVBhaXJGb3JPdXRwdXQoYmlwMzI6IEJJUDMySW50ZXJmYWNlLCBvdXRwdXQ6IFBzYnRPdXRwdXQpOiBCSVAzMkludGVyZmFjZSB8IHVuZGVmaW5lZCB7XHJcbiAgcmV0dXJuIG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aFxyXG4gICAgPyBVdHhvUHNidC5kZXJpdmVLZXlQYWlyKGJpcDMyLCBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uLCB7IGlnbm9yZVk6IHRydWUgfSlcclxuICAgIDogb3V0cHV0LmJpcDMyRGVyaXZhdGlvbj8ubGVuZ3RoXHJcbiAgICA/IFV0eG9Qc2J0LmRlcml2ZUtleVBhaXIoYmlwMzIsIG91dHB1dC5iaXAzMkRlcml2YXRpb24sIHsgaWdub3JlWTogZmFsc2UgfSlcclxuICAgIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmllZCBvdXRwdXQgaW4gYSBQU0JUIGlzIGFuIG91dHB1dCBvZiB0aGUgd2FsbGV0IHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiByb290IG5vZGVzLlxyXG4gKiBAcGFyYW0gcHNidCAtIFRoZSBQU0JUIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0gb3V0cHV0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCB0byBjaGVjay5cclxuICogQHBhcmFtIHJvb3RXYWxsZXROb2RlcyAtIFRoZSByb290IG5vZGVzIHJlcHJlc2VudGluZyB0aGUgd2FsbGV0LlxyXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgb3V0cHV0IGJlbG9uZ3MgdG8gdGhlIHdhbGxldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dhbGxldE91dHB1dChwc2J0OiBVdHhvUHNidCwgb3V0cHV0SW5kZXg6IG51bWJlciwgcm9vdFdhbGxldE5vZGVzOiBUcmlwbGU8QklQMzJJbnRlcmZhY2U+KTogYm9vbGVhbiB7XHJcbiAgY29uc3Qgb3V0cHV0ID0gY2hlY2tGb3JPdXRwdXQocHNidC5kYXRhLm91dHB1dHMsIG91dHB1dEluZGV4KTtcclxuXHJcbiAgY29uc3QgcHViS2V5cyA9IHJvb3RXYWxsZXROb2Rlcy5tYXAoKHJvb3ROb2RlKSA9PiBkZXJpdmVLZXlQYWlyRm9yT3V0cHV0KHJvb3ROb2RlLCBvdXRwdXQpPy5wdWJsaWNLZXkpO1xyXG5cclxuICBpZiAoIWlzQnVmZmVyQXJyYXkocHViS2V5cykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG91dHB1dFNjcmlwdCA9IHBzYnQuZ2V0T3V0cHV0U2NyaXB0KG91dHB1dEluZGV4KTtcclxuICByZXR1cm4gc2NyaXB0VHlwZXMyT2YzLnNvbWUoKHNjcmlwdFR5cGUpID0+XHJcbiAgICBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzKHB1YktleXMsIHNjcmlwdFR5cGUpLnNjcmlwdFB1YktleS5lcXVhbHMob3V0cHV0U2NyaXB0KVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyBpbmRpY2VzIG9mIGFsbCBvdXRwdXRzIGluIGEgUFNCVCB0aGF0IGJlbG9uZyB0byB0aGUgd2FsbGV0IHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiByb290IG5vZGVzLlxyXG4gKiBAcGFyYW0gcHNidCAtIFRoZSBQU0JUIHRvIHNlYXJjaCB0aHJvdWdoLlxyXG4gKiBAcGFyYW0gcm9vdFdhbGxldE5vZGVzIC0gVGhlIHJvb3Qgbm9kZXMgcmVwcmVzZW50aW5nIHRoZSB3YWxsZXQuXHJcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGluZGljZXMgY29ycmVzcG9uZGluZyB0byB3YWxsZXQgb3V0cHV0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kV2FsbGV0T3V0cHV0SW5kaWNlcyhwc2J0OiBVdHhvUHNidCwgcm9vdFdhbGxldE5vZGVzOiBUcmlwbGU8QklQMzJJbnRlcmZhY2U+KTogbnVtYmVyW10ge1xyXG4gIHJldHVybiBwc2J0LmRhdGEub3V0cHV0cy5mbGF0TWFwKChfLCBpKSA9PiAoaXNXYWxsZXRPdXRwdXQocHNidCwgaSwgcm9vdFdhbGxldE5vZGVzKSA/IFtpXSA6IFtdKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBhbW91bnQgb2YgYWxsIHdhbGxldCBvdXRwdXRzIGluIGEgUFNCVCBmb3IgdGhlIHdhbGxldCByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gcm9vdCBub2Rlcy5cclxuICogQHBhcmFtIHBzYnQgLSBUaGUgUFNCVCB0byBjYWxjdWxhdGUgZm9yLlxyXG4gKiBAcGFyYW0gcm9vdFdhbGxldE5vZGVzIC0gVGhlIHJvb3Qgbm9kZXMgcmVwcmVzZW50aW5nIHRoZSB3YWxsZXQuXHJcbiAqIEByZXR1cm5zIFRoZSB0b3RhbCBhbW91bnQgb2Ygd2FsbGV0IG91dHB1dHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG90YWxBbW91bnRPZldhbGxldE91dHB1dHMocHNidDogVXR4b1BzYnQsIHJvb3RXYWxsZXROb2RlczogVHJpcGxlPEJJUDMySW50ZXJmYWNlPik6IGJpZ2ludCB7XHJcbiAgY29uc3QgaW5kaWNlcyA9IGZpbmRXYWxsZXRPdXRwdXRJbmRpY2VzKHBzYnQsIHJvb3RXYWxsZXROb2Rlcyk7XHJcbiAgY29uc3QgdHhPdXRwdXRzID0gcHNidC50eE91dHB1dHM7XHJcbiAgcmV0dXJuIGluZGljZXMucmVkdWNlKChzdW0sIGkpID0+IHN1bSArIHR4T3V0cHV0c1tpXS52YWx1ZSwgQmlnSW50KDApKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGluZGljZXMgb2YgYWxsIGludGVybmFsIG91dHB1dHMgaW4gYSBQU0JULCBpZGVudGlmaWVkIGFzIG91dHB1dHMgYmVsb25naW5nIHRvIHRoZSB3YWxsZXQncyByb290IG5vZGVzIHdpdGhpbiB0aGUgUFNCVC5cclxuICogQHBhcmFtIHBzYnQgLSBUaGUgUFNCVCBjb250YWluaW5nIHRoZSB3YWxsZXQncyByb290IG5vZGVzIGFzIGluZGljYXRlZCBieSBnbG9iYWwgWHB1YnMuXHJcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGluZGljZXMgb2YgaW50ZXJuYWwgb3V0cHV0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW50ZXJuYWxPdXRwdXRJbmRpY2VzKHBzYnQ6IFV0eG9Qc2J0KTogbnVtYmVyW10ge1xyXG4gIGNvbnN0IHJvb3ROb2RlcyA9IGdldFNvcnRlZFJvb3ROb2Rlcyhwc2J0KTtcclxuICByZXR1cm4gZmluZFdhbGxldE91dHB1dEluZGljZXMocHNidCwgcm9vdE5vZGVzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIGFtb3VudCBvZiBhbGwgaW50ZXJuYWwgb3V0cHV0cyBpbiBhIFBTQlQsIGlkZW50aWZpZWQgYXMgb3V0cHV0cyBiZWxvbmdpbmcgdG8gdGhlIHdhbGxldCdzIHJvb3Qgbm9kZXMgd2l0aGluIHRoZSBQU0JULlxyXG4gKiBAcGFyYW0gcHNidCAtIFRoZSBQU0JUIGNvbnRhaW5pbmcgdGhlIHdhbGxldCdzIHJvb3Qgbm9kZXMgYXMgaW5kaWNhdGVkIGJ5IGdsb2JhbCBYcHVicy5cclxuICogQHJldHVybnMgVGhlIHRvdGFsIGFtb3VudCBvZiBpbnRlcm5hbCBvdXRwdXRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvdGFsQW1vdW50T2ZJbnRlcm5hbE91dHB1dHMocHNidDogVXR4b1BzYnQpOiBiaWdpbnQge1xyXG4gIGNvbnN0IHJvb3ROb2RlcyA9IGdldFNvcnRlZFJvb3ROb2Rlcyhwc2J0KTtcclxuICByZXR1cm4gZ2V0VG90YWxBbW91bnRPZldhbGxldE91dHB1dHMocHNidCwgcm9vdE5vZGVzKTtcclxufVxyXG4iXX0=